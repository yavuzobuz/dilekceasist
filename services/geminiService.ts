import { type ChatMessage, type GeneratePetitionParams, UploadedFile, WebSearchResult, AnalysisData, UserRole, CaseDetails, ChatContext, LawyerInfo, ContactInfo } from '../types';

const API_BASE_URL = '/api/gemini';

// Helper to handle API response errors
async function handleResponse(response: Response) {
    if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        throw new Error(errorData.error || `API Error: ${response.statusText}`);
    }
    return response.json();
}

export async function analyzeDocuments(
    uploadedFiles: UploadedFile[],
    udfTextContent: string,
    wordTextContent: string
): Promise<AnalysisData> {
    if (uploadedFiles.length === 0 && !udfTextContent && !wordTextContent) {
        throw new Error("Analiz edilecek hiçbir belge veya metin içeriği sağlanmadı.");
    }

    // Convert files to format expected by backend (already in correct format with data as base64)
    const payload = {
        uploadedFiles,
        udfTextContent,
        wordTextContent
    };

    const data = await handleResponse(await fetch(`${API_BASE_URL}/analyze`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload)
    }));

    // The backend returns { text: string } where text is the JSON string
    try {
        const json = JSON.parse(data.text);

        // Ensure manual parsing logic matches backend's expected output structure
        // Since backend just returns the text generated by Gemini, we need to parse it here 
        // OR the backend could parse it. In the current server.js, backend sends `text`.

        const caseDetails: CaseDetails = {
            court: json.caseDetails?.court || '',
            fileNumber: json.caseDetails?.fileNumber || '',
            decisionNumber: json.caseDetails?.decisionNumber || '',
            decisionDate: json.caseDetails?.decisionDate || '',
        };

        const lawyerInfo: LawyerInfo | undefined = json.lawyerInfo ? {
            name: json.lawyerInfo.name || '',
            address: json.lawyerInfo.address || '',
            phone: json.lawyerInfo.phone || '',
            email: json.lawyerInfo.email || '',
            barNumber: json.lawyerInfo.barNumber || '',
            bar: json.lawyerInfo.bar || '',
            title: json.lawyerInfo.title || 'Avukat',
            tcNo: json.lawyerInfo.tcNo,
        } : undefined;

        const contactInfo: ContactInfo[] | undefined = json.contactInfo?.map((contact: any) => ({
            name: contact.name || '',
            address: contact.address || '',
            phone: contact.phone || '',
            email: contact.email || '',
            tcNo: contact.tcNo,
        }));

        return {
            summary: json.summary || '',
            potentialParties: Array.from(new Set(json.potentialParties || [])) as string[],
            caseDetails: caseDetails,
            lawyerInfo: lawyerInfo,
            contactInfo: contactInfo
        };

    } catch (e) {
        console.error("Failed to parse analysis JSON from backend:", e);
        return {
            summary: "Sunucudan gelen analiz sonucu işlenemedi.",
            potentialParties: [],
            caseDetails: { court: '', fileNumber: '', decisionNumber: '', decisionDate: '' }
        };
    }
}

export async function generateSearchKeywords(analysisText: string, userRole: UserRole): Promise<string[]> {
    const data = await handleResponse(await fetch(`${API_BASE_URL}/keywords`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ analysisText, userRole })
    }));

    try {
        const json = JSON.parse(data.text);
        return json.keywords || [];
    } catch (e) {
        return [];
    }
}

export async function performWebSearch(keywords: string[]): Promise<WebSearchResult> {
    const data = await handleResponse(await fetch(`${API_BASE_URL}/web-search`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ keywords })
    }));

    return {
        summary: data.text,
        sources: data.groundingMetadata?.groundingChunks?.map((c: any) => ({
            uri: c.web?.uri,
            title: c.web?.title
        })) || []
    };
}

export async function generatePetition(
    params: GeneratePetitionParams
): Promise<string> {
    const data = await handleResponse(await fetch(`${API_BASE_URL}/generate-petition`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(params)
    }));

    return data.text;
}

export async function* streamChatResponse(
    chatHistory: ChatMessage[],
    analysisSummary: string,
    context: ChatContext,
    files?: { name: string; mimeType: string; data: string }[]
): AsyncGenerator<any> { // Using 'any' for the chunk type as we don't import specific SDK types
    try {
        const response = await fetch(`${API_BASE_URL}/chat`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ chatHistory, analysisSummary, context, files })
        });

        if (!response.ok) throw new Error('Chat API failed');
        if (!response.body) throw new Error('No response body');

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop() || ''; // Keep incomplete line in buffer

            for (const line of lines) {
                if (line.trim()) {
                    try {
                        const chunk = JSON.parse(line);
                        yield chunk;
                    } catch (e) {
                        console.error('Error parsing chat stream chunk:', e);
                    }
                }
            }
        }
    } catch (e) {
        console.error('Stream Error:', e);
        throw e;
    }
}

export async function rewriteText(textToRewrite: string): Promise<string> {
    const data = await handleResponse(await fetch(`${API_BASE_URL}/rewrite`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ textToRewrite })
    }));
    return data.text;
}

export async function reviewPetition(
    params: GeneratePetitionParams & { currentPetition: string }
): Promise<string> {
    const data = await handleResponse(await fetch(`${API_BASE_URL}/review`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(params)
    }));
    return data.text;
}